<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Puzzle Game</title>
  <style>
    #puzzleContainer {
      display: grid;
      gap: 2px;
    }
    .puzzlePiece {
      cursor: pointer;
      border: 1px solid #ccc;
      user-select: none;
      position: absolute;
    }
    #message {
      margin-top: 20px;
      font-weight: bold;
      color: green;
    }
    #version {
      margin-top: 20px;
      font-weight: bold;
      color: blue;
    }
    #restartButton {
      display: none;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="puzzleContainer"></div>
  <div id="message"></div>
  <button id="restartButton">Ricomincia</button>
  <div id="version">Versione: 1.7</div> <!-- Aggiungi la versione qui -->

  <script>
    const imageUrl = 'https://github.com/GiuPeRib/Provisional_2/blob/main/Apparato%20di%20distillazione%20semplice%20-%20Copia.jpg?raw=true';
    let draggedElement = null;
    let touchStartX = 0;
    let touchStartY = 0;
    let offsetX = 0;
    let offsetY = 0;

    function isMobile() {
      return /Mobi|Android/i.test(navigator.userAgent);
    }

    function createPuzzle(imageUrl) {
      const puzzleContainer = document.getElementById('puzzleContainer');
      puzzleContainer.innerHTML = '';
      const pieceSize = 100; // Dimensione del pezzo del puzzle
      const img = new Image();
      img.src = imageUrl;
      img.onload = function() {
        const cols = Math.ceil(img.width / pieceSize);
        const rows = Math.ceil(img.height / pieceSize);

        puzzleContainer.style.gridTemplateColumns = `repeat(${cols}, ${pieceSize}px)`;
        puzzleContainer.style.gridTemplateRows = `repeat(${rows}, ${pieceSize}px)`;

        const pieces = [];

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const piece = document.createElement('canvas');
            piece.classList.add('puzzlePiece');
            piece.width = pieceSize;
            piece.height = pieceSize;
            piece.draggable = false;
            const context = piece.getContext('2d');
            context.drawImage(img, col * pieceSize, row * pieceSize, pieceSize, pieceSize, 0, 0, pieceSize, pieceSize);
            piece.dataset.position = `${row}-${col}`;
            pieces.push(piece);
          }
        }

        pieces.sort(() => Math.random() - 0.5);

        pieces.forEach((piece, index) => {
          piece.dataset.index = index;

          if (isMobile()) {
            piece.addEventListener('touchstart', handleTouchStart);
            piece.addEventListener('touchmove', handleTouchMove);
            piece.addEventListener('touchend', handleTouchEnd);
          } else {
            piece.addEventListener('pointerdown', handlePointerDown);
            piece.addEventListener('pointermove', handlePointerMove);
            piece.addEventListener('pointerup', handlePointerUp);
          }

          puzzleContainer.appendChild(piece);
        });
      };
    }

    function handlePointerDown(event) {
      if (!puzzleCompleted) {
        draggedElement = event.target;
        offsetX = event.offsetX;
        offsetY = event.offsetY;
        draggedElement.setPointerCapture(event.pointerId);
      }
    }

    function handlePointerMove(event) {
      if (draggedElement) {
        const containerRect = puzzleContainer.getBoundingClientRect();
        draggedElement.style.left = `${event.clientX - containerRect.left - offsetX}px`;
        draggedElement.style.top = `${event.clientY - containerRect.top - offsetY}px`;
      }
    }

    function handlePointerUp(event) {
      if (draggedElement) {
        const targetElement = document.elementFromPoint(event.clientX, event.clientY).closest('.puzzlePiece');
        const sourceIndex = draggedElement.dataset.index;
        const targetIndex = targetElement ? targetElement.dataset.index : null;

        if (draggedElement && targetElement && draggedElement !== targetElement && !puzzleCompleted) {
          swapPieces(sourceIndex, targetIndex);
          checkPuzzle(); // Verifica automatica dopo lo scambio
        }

        draggedElement.style.left = '0px'; // Reimposta la posizione
        draggedElement.style.top = '0px'; // Reimposta la posizione
        draggedElement.releasePointerCapture(event.pointerId);
        draggedElement = null;
      }
    }

    function handleTouchStart(event) {
      if (!puzzleCompleted) {
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        draggedElement = event.target;
      }
    }

    function handleTouchMove(event) {
      event.preventDefault();
      if (draggedElement) {
        const touch = event.touches[0];
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        draggedElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
      }
    }

    function handleTouchEnd(event) {
      event.preventDefault();
      const touch = event.changedTouches[0];
      const targetElement = document.elementFromPoint(touch.clientX, touch.clientY).closest('.puzzlePiece');
      const sourceIndex = draggedElement.dataset.index;
      const targetIndex = targetElement ? targetElement.dataset.index : null;

      if (draggedElement && targetElement && draggedElement !== targetElement && !puzzleCompleted) {
        swapPieces(sourceIndex, targetIndex);
        checkPuzzle(); // Verifica automatica dopo lo scambio
      }

      draggedElement.style.transform = ''; // Reimposta la trasformazione
      draggedElement = null;
    }

    function swapPieces(sourceIndex, targetIndex) {
      const puzzleContainer = document.getElementById('puzzleContainer');
      const sourcePiece = puzzleContainer.querySelector(`[data-index='${sourceIndex}']`);
      const targetPiece = puzzleContainer.querySelector(`[data-index='${targetIndex}']`);

      if (sourcePiece && targetPiece) {
        // Scambia gli indici
        [sourcePiece.dataset.index, targetPiece.dataset.index] = [targetIndex, sourceIndex];

        // Scambia le posizioni nel DOM
        const sourceLeft = sourcePiece.style.left;
        const sourceTop = sourcePiece.style.top;
        sourcePiece.style.left = targetPiece.style.left;
        sourcePiece.style.top = targetPiece.style.top;
        targetPiece.style.left = sourceLeft;
        targetPiece.style.top = sourceTop;
      }
    }

    let puzzleCompleted = false;

    function checkPuzzle() {
      const pieces = document.querySelectorAll('.puzzlePiece');
      let isCorrect = true;

      pieces.forEach((piece, index) => {
        const [originalRow, originalCol] = piece.dataset.position.split('-').map(Number);
        const currentRow = Math.floor(index / Math.sqrt(pieces.length));
        const currentCol = index % Math.sqrt(pieces.length);

        if (originalRow !== currentRow || originalCol !== currentCol) {
          isCorrect = false;
        }
      });

      const message = document.getElementById('message');
      if (isCorrect) {
        message.textContent = 'Congratulazioni! Hai ricomposto correttamente il puzzle!';
        puzzleCompleted = true;
        document.getElementById('restartButton').style.display = 'block';
        // Disabilita il drag sui pezzi
        document.querySelectorAll('.puzzlePiece').forEach(piece => {
          piece.draggable = false;
        });
      } else {
        message.textContent = 'Il puzzle non Ã¨ ancora corretto. Continua a provare!';
      }
    }

    document.getElementById('restartButton').addEventListener('click', () => {
      puzzleCompleted = false;
      createPuzzle(imageUrl);
      document.getElementById('restartButton').style.display = 'none';
      document.getElementById('message').textContent = '';
    });

    createPuzzle(imageUrl);
  </script>
</body>
</html>
